/* ===============================================================================
   Advanced Data Analytics
   =============================================================================== 

   Script Purpose:
       This script performs advanced analytical queries to uncover business trends,
       customer behaviors, and product performance insights.

   =============================================================================== */


/* ===============================================================================
   Changes Over Time Analysis
   -----------------------------------------------------------------------------
   Purpose:
       Analyze sales performance and customer activity over different time periods.
       Provides both high-level and detailed insights to support strategic decisions.
   =============================================================================== */

-- Changes over years
SELECT
	YEAR(order_date) AS order_year,
	SUM(sales_amount) AS total_sales,
	COUNT(DISTINCT customer_key) AS customer_count,
	SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date)
ORDER BY YEAR(order_date);

-- Changes over months across all years
-- Used to identify seasonality or recurring trends
SELECT
	MONTH(order_date) AS order_month,
	SUM(sales_amount) AS total_sales,
	COUNT(DISTINCT customer_key) AS customer_count,
	SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY MONTH(order_date)
ORDER BY MONTH(order_date);

-- Monthly trends by year
-- Provides deeper understanding of seasonality per year.
-- Unusual patterns may indicate business-related events or anomalies.
SELECT
    FORMAT(CAST(order_date AS DATE), 'yyyy-MMM') AS order_date,
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS customer_count,
    SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY FORMAT(CAST(order_date AS DATE), 'yyyy-MMM')
ORDER BY MIN(CAST(order_date AS DATE));


/* ===============================================================================
   Cumulative Analysis
   -----------------------------------------------------------------------------
   Purpose:
       Evaluate business performance over time using running totals
       and moving averages to detect long-term growth or decline.
   =============================================================================== */

WITH sales_over_time AS (
	SELECT
		YEAR(order_date) AS order_year,
		MONTH(order_date) AS order_month,
        SUM(sales_amount) AS total_sales,
		AVG(price) AS avg_price
	FROM gold.fact_sales
	WHERE order_date IS NOT NULL
	GROUP BY YEAR(order_date), MONTH(order_date)
)
SELECT
	order_year,
    order_month,
	DATENAME(month, DATEFROMPARTS(order_year, order_month, 1)) AS order_month_name,
    total_sales,
    SUM(total_sales) OVER (PARTITION BY order_year ORDER BY order_month) AS running_total_sales,
	avg_price,
	AVG(avg_price) OVER (PARTITION BY order_year ORDER BY order_month) AS moving_avg
FROM sales_over_time
ORDER BY order_year, order_month;


 /* ===============================================================================
   Performance Analysis
   -----------------------------------------------------------------------------
   Purpose:
       Compare current results to historical averages and previous years
       to measure performance, detect growth, and highlight underperforming products.
   =============================================================================== */

WITH yearly_product_sales AS (
	SELECT
		YEAR(fs.order_date) AS order_year,
		dp.product_name,
		SUM(fs.sales_amount) AS current_sales
	FROM gold.fact_sales fs
	LEFT JOIN gold.dim_products dp
		ON fs.product_key = dp.product_key
	WHERE order_date IS NOT NULL
	GROUP BY YEAR(order_date), product_name
)
SELECT
	order_year,
	product_name,
	current_sales,
	-- Compare to productâ€™s historical average
	AVG(current_sales) OVER (PARTITION BY product_name) AS avg_sales,
	current_sales - AVG(current_sales) OVER (PARTITION BY product_name) AS diff_avg,
	CASE WHEN (current_sales - AVG(current_sales) OVER (PARTITION BY product_name)) > 0 THEN 'Above Avg'
	     WHEN (current_sales - AVG(current_sales) OVER (PARTITION BY product_name)) < 0 THEN 'Below Avg'
		 ELSE 'Equal To Avg'
	END AS avg_change,
	-- Year-over-year comparison
	LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS py_sales,
	current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS diff_py,
	CASE WHEN (current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year)) > 0 THEN 'Increase'
	     WHEN (current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year)) < 0 THEN 'Decrease'
		 ELSE 'No Change'
	END AS py_change
FROM yearly_product_sales
ORDER BY product_name, order_year;


/* ===============================================================================
   Part-To-Whole Analysis
   -----------------------------------------------------------------------------
   Purpose:
       Examine how each category contributes to total sales and inventory.
       Helps identify overreliance on specific product lines.
   =============================================================================== */

-- Category sales overview
-- Bikes dominate total sales, indicating high business dependency.
-- Consider diversifying or investing in other categories to reduce risk.
WITH category_sales AS (
	SELECT
		dp.category,
		SUM(fs.sales_amount) AS total_sales
	FROM gold.fact_sales fs
	LEFT JOIN gold.dim_products dp
		ON fs.product_key = dp.product_key
	GROUP BY dp.category
)
SELECT
	category,
	total_sales,
	SUM(total_sales) OVER() AS overall_sales,
	CONCAT(ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER()) * 100, 2), '%') AS percentage_of_total
FROM category_sales
ORDER BY percentage_of_total DESC;

-- Inventory vs. profitability
-- Accessories represent over 50% of inventory but generate only ~2% of profit.
-- Bikes represent ~25% of inventory yet contribute over 95% of profit.
-- Recommendation: Evaluate demand and optimize stock allocation accordingly.
WITH category_quantity AS (
	SELECT
		dp.category,
		SUM(fs.quantity) AS total_quantity
	FROM gold.fact_sales fs
	LEFT JOIN gold.dim_products dp
		ON fs.product_key = dp.product_key
	GROUP BY dp.category
)
SELECT
	category,
	total_quantity,
	SUM(total_quantity) OVER() AS overall_quantity,
	CONCAT(ROUND((CAST(total_quantity AS FLOAT) / SUM(total_quantity) OVER()) * 100, 2), '%') AS percentage_of_total
FROM category_quantity
ORDER BY percentage_of_total DESC;


/* ===============================================================================
   Data Segmentation
   -----------------------------------------------------------------------------
   Purpose:
       Group data into meaningful ranges to analyze distribution and correlations
       (e.g., cost tiers, spending behaviors).
   =============================================================================== */

-- Segment products by cost range
WITH product_segments AS (
	SELECT 
		product_key,
		product_name,
		cost,
		CASE WHEN cost < 100 THEN '<100'
			 WHEN cost >= 100 AND cost < 500 THEN '100-500'
			 WHEN cost >= 500 AND cost < 1000 THEN '500-1000'
			 WHEN cost >= 1000 AND cost < 1500 THEN '1000-1500'
			 WHEN cost >= 1500 AND cost < 2000 THEN '1500-2000'
			 ELSE '>2000'
		END AS cost_range
	FROM gold.dim_products
)
SELECT
	cost_range,
	COUNT(product_key) AS total_products
FROM product_segments
GROUP BY cost_range
ORDER BY total_products DESC;

-- Segment customers by spending behavior
WITH customer_spending AS (
	SELECT
		customer_key,
		MIN(order_date) AS first_order,
		MAX(order_date) AS last_order,
		DATEDIFF(month, MIN(order_date), MAX(order_date)) AS lifespan,
		SUM(sales_amount) AS total_spending
	FROM gold.fact_sales 
	GROUP BY customer_key
)
SELECT
	customer_key,
	lifespan,
	total_spending,
	CASE WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
		 WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
		 ELSE 'New'
	END AS customer_segments
FROM customer_spending
ORDER BY lifespan DESC, total_spending DESC;

-- Count total customers in each group
SELECT
	customer_segments,
	COUNT(customer_key) AS total_customers
FROM (
	SELECT
		customer_key,
		CASE WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
			 WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
			 ELSE 'New'
		END AS customer_segments
	FROM customer_spending
) t
GROUP BY customer_segments
ORDER BY total_customers DESC;


/* ===============================================================================
   Additional Analysis
   -----------------------------------------------------------------------------
   Purpose:
       Combine product and sales data for a high-level profitability overview.
   =============================================================================== */

WITH base_query AS (
	SELECT
		dp.product_key,
		dp.product_name,
		dp.category,
		dp.subcategory_id AS subcategory,
		dp.cost,
		fs.sales_amount,
		fs.quantity,
		fs.price,
		fs.order_number,
		fs.order_date,
		fs.customer_key
	FROM gold.fact_sales fs
	LEFT JOIN gold.dim_products dp
		ON fs.product_key = dp.product_key
)
SELECT
	product_key,
	product_name,
	category,
	subcategory,
	SUM(cost) AS total_cost,
	SUM(sales_amount) AS total_revenue,
	SUM(quantity) AS total_quantity,
	AVG(price) AS avg_price
FROM base_query
GROUP BY
	product_key,
	product_name,
	category,
	subcategory;
